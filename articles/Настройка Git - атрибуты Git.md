# Настройка Git - атрибуты Git

## Атрибуты Git

Некоторые из этих настроек также могут быть указаны для пути, так что Git применяет эти настройки только для подкаталога или подмножества файлов. Эти специфичные для пути настройки называются атрибутами Git и задаются либо в файле `.gitattributes` в одном из ваших каталогов (обычно в корне вашего проекта), либо в файле `.git/info/attribute`, если вы не хотите, чтобы файл атрибутов был зафиксирован в вашем проекте.

Используя атрибуты, вы можете делать такие вещи, как указание отдельных стратегий слияния для отдельных файлов или каталогов в вашем проекте, указывать Git, как создавать нетекстовые файлы, или использовать Git-фильтр для содержимого перед тем, как проверять его в Git или из него. В этом разделе вы узнаете о некоторых атрибутах, которые вы можете установить в своих путях в своем проекте Git, и увидите несколько примеров использования этой функции на практике.

### Двоичные файлы

Один интересный трюк, для которого вы можете использовать атрибуты Git - это сообщить Git, какие файлы являются двоичными (в противном случае он не сможет это выяснить), и дать Git специальные инструкции о том, как обрабатывать эти файлы. Например, некоторые текстовые файлы могут быть сгенерированы машиной и не могут быть различимы, тогда как некоторые двоичные файлы могут быть различимы. Вы увидите, как сказать Git, что есть что.

#### Идентификация бинарных файлов

Некоторые файлы выглядят как текстовые файлы, но в целом они должны рассматриваться как двоичные данные. Например, проекты Xcode в macOS содержат файл, который заканчивается на `.pbxproj`, который в основном представляет собой набор данных JSON (текстовый формат данных JavaScript), записанный на диск IDE, который записывает ваши параметры сборки и так далее. Хотя технически это текстовый файл (потому что это все UTF-8), вы не хотите рассматривать его как таковой, потому что это действительно легкая база данных - вы не можете объединить содержимое, если его изменяют два человека, и различия, как правило, не помогают. Файл предназначен для использования машиной. По сути, вы хотите рассматривать его как двоичный файл.

Чтобы заставить Git обрабатывать все файлы `pbxproj` как двоичные данные, добавьте следующую строку в ваш файл `.gitattributes`:

```ini
*.pbxproj binary
```

Теперь Git не будет пытаться конвертировать или исправлять ошибки CRLF; он также не будет пытаться вычислить или распечатать diff для изменений в этом файле, когда вы запустите `git show` или `git diff` в вашем проекте.

#### Сравнения Бинарных Файлов

Вы также можете использовать функциональность атрибутов Git для эффективного сравнения двоичных файлов. Вы делаете это, сообщая Git, как преобразовать ваши двоичные данные в текстовый формат, который можно сравнить с помощью обычного diff.

Во-первых, вы будете использовать эту технику для решения одной из самых досадных проблем, известных человечеству: контроль версий документов Microsoft Word. Все знают, что Word - самый ужасный редактор из всех, но, как ни странно, все еще используют его. Если вы хотите контролировать документы Word, вы можете поместить их в Git-репозиторий и делать коммиты время от времени; но что хорошего в этом? Если вы запускаете git diff нормально, вы видите только что-то вроде этого:

```console
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ
```

Вы не можете напрямую сравнить две версии, если не проверите их и не отсканируете их вручную, верно? Оказывается, вы можете сделать это довольно хорошо, используя атрибуты Git. Поместите следующую строку в ваш файл `.gitattributes`:

```ini
*.docx diff=word
```

Это говорит Git, что любой файл, соответствующий этому шаблону (`.docx`), должен использовать фильтр «word», когда вы пытаетесь просмотреть diff, содержащий изменения. Что такое «word» фильтр? Вы должны настроить это. Здесь вы сконфигурируете Git для использования программы `docx2txt` для преобразования документов Word в читаемые текстовые файлы, которые затем будут правильно отображаться.

Во-первых, вам нужно установить `docx2txt`; Вы можете скачать его с [https://sourceforge.net/projects/docx2txt](https://sourceforge.net/projects/docx2txt). Следуйте инструкциям в файле `INSTALL`, чтобы поместить его туда, где его может найти ваша оболочка. Затем вы напишите скрипт-обертку для преобразования вывода в формат, ожидаемый Git. Создайте файл, который находится где-то на вашем пути, под названием `docx2txt`, и добавьте следующее содержимое:

```console
#!/bin/bash
docx2txt.pl "$1" -
```

Не забудьте `chmod a + x` этот файл. Наконец, вы можете настроить Git для использования этого скрипта:

```console
$ git config diff.word.textconv docx2txt
```

Теперь Git знает, что если он пытается выполнить различие между двумя снимками, и любой из файлов заканчивается на `.docx`, он должен запустить эти файлы через фильтр «word», который определен как программа« docx2txt». Это эффективно делает хорошие текстовые версии ваших файлов Word, прежде чем пытаться их различать.

Вот пример: Глава 1 этой книги была преобразована в формат Word и помещена в репозиторий Git. Затем был добавлен новый абзац. Вот что показывает `git diff`:

```console
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.
```

Git успешно и лаконично сообщает нам, что мы добавили строку «Testing: 1, 2, 3.», и это правильно. Он не идеален - изменения форматирования здесь не появятся - но это, безусловно, работает.

Еще одна интересная проблема, которую вы можете решить таким образом, заключается в разграничении файлов изображений. Один из способов сделать это - запустить файлы изображений через фильтр, который извлекает их EXIF-информацию - метаданные, записанные в большинстве форматов изображений. Если вы скачаете и установите программу `exiftool`, вы можете использовать ее для преобразования ваших изображений в текст о метаданных, поэтому, по крайней мере, diff покажет вам текстовое представление всех произошедших изменений. Поместите следующую строку в ваш файл `.gitattributes`:

```ini
*.png diff=exif
```

Настройте Git для использования этого инструмента:

```console
$ git config diff.exif.textconv exiftool
```

Если вы замените изображение в своем проекте и запустите `git diff`, вы увидите что-то вроде этого:

```diff
diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha
```

Вы можете легко увидеть, что размер файла и размеры изображения изменились.

### Расширение ключевого слова

Разработчики, использующие эти системы, часто запрашивают расширение ключевых слов в стиле SVN или CVS. Основная проблема с этим в Git состоит в том, что вы не можете изменить файл с информацией о коммите после того, как вы зафиксировали, потому что Git сначала проверяет суммы файла. Тем не менее, вы можете вставить текст в файл, когда он извлечен, и удалить его снова, прежде чем он будет добавлен в коммит. Атрибуты Git предлагают вам два способа сделать это.

Во-первых, вы можете автоматически ввести контрольную сумму SHA-1 большого двоичного объекта в поле `$Id$` в файле. Если вы установите этот атрибут для файла или набора файлов, то в следующий раз, когда вы извлечете эту ветку, Git заменит это поле на SHA-1 большого двоичного объекта. Важно отметить, что это не SHA-1 коммита, а сам блоб. Поместите следующую строку в ваш файл `.gitattributes`:

```ini
*.txt ident
```

Добавьте ссылку `$Id$` в тестовый файл:

```console
$ echo '$Id$' > test.txt
```

В следующий раз, когда вы извлечете этот файл, Git вставит SHA-1 большого двоичного объекта:

```console
$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $
```

Однако этот результат имеет ограниченное применение. Если вы использовали подстановку ключевых слов в CVS или Subversion, вы можете включить метку даты - SHA-1 не так уж полезен, потому что это довольно случайно, и вы не можете сказать, если один SHA -1 старше или новее другого, просто посмотрев на них.

Оказывается, вы можете написать свои собственные фильтры для выполнения подстановок в файлах при коммите/проверке. Они называются «чистыми»(clean) и «грязными»(smudge) фильтрами. В файле `.gitattributes` вы можете установить фильтр для определенных путей, а затем настроить сценарии, которые будут обрабатывать файлы непосредственно перед их извлечением (“smudge”, см. [The “smudge” filter is run on checkout.](https://git-scm.com/book/en/v2/ch00/filters_a) и перед их постановкой (“clean”, см. [The “clean” filter is run when files are staged.](https://git-scm.com/book/en/v2/ch00/filters_b)). Эти фильтры могут быть настроены на все виды забавных вещей.

![](/images/8c34c1aeb3ddf12194cfa7ac92160491.png)

Рисунок 144. Фильтр «smudge» запускается при checkout.

![The ``smudge'' filter is run on checkout.](/images/2b92285c3b797e606ca4792eb9ff5dde.png)Figure 144. The “smudge” filter is run on checkout.![The ``clean'' filter is run when files are staged.](/images/ac5b46b36c9200ccec5d88a7159350d9.png)

Рисунок 145. «clean» фильтр запускается, когда файлы находятся в стадии подготовки.

В исходном сообщении о фиксации для этой функции приведен простой пример запуска всего исходного кода на языке C с помощью программы `indent` перед фиксацией. Вы можете установить его, установив атрибут фильтра в вашем файле `.gitattributes` для фильтрации файлов \*.c с фильтром «indent»:

```ini
*.c filter=indent
```

Затем скажите Git, что делает фильтр «indent» в smudge и clean:

```console
$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat
```

В этом случае, когда вы фиксируете файлы, которые соответствуют `*.c`, Git будет запускать их через программу indent перед тем, как запускать их, а затем запускать через программу `cat`, прежде чем проверять их обратно на диск. Программа `cat` по сути ничего не делает: она выдает те же данные, что и отправили в нее. Эта комбинация эффективно фильтрует все файлы с исходным кодом на языке C с помощью `indent` перед фиксацией.

Другой интересный пример - расширение ключевого слова `$Date$` в стиле RCS. Чтобы сделать это правильно, вам нужен небольшой скрипт, который берет имя файла, вычисляет дату последней фиксации для этого проекта и вставляет дату в файл. Вот небольшой скрипт Ruby, который делает это:

```ruby
#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')
```

Все, что делает скрипт, это получает последнюю дату фиксации из команды `git log`, вставляет ее в любые строки `$Date$`, которые он видит в stdin, и печатает результаты - это должно быть просто сделать на любом языке, который вам удобен. Вы можете назвать этот файл `expand_date` и указать его в своем пути. Теперь вам нужно настроить фильтр в Git (назовите его `dater`) и сказать ему использовать ваш фильтр "expand_date" для удаления файлов при оформлении заказа. Вы будете использовать выражение Perl для очистки этого при фиксации:

```console
$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'
```

Этот фрагмент Perl удаляет все, что он видит в строке `$Date$`, чтобы вернуться к тому, с чего вы начали. Теперь, когда ваш фильтр готов, вы можете проверить его, установив атрибут Git для этого файла, который включает новый фильтр, и создайте файл с ключевым словом `$Date$`:

```ini
date*.txt filter=dater
```

```console
$ echo '# $Date$' > date_test.txt
```

Если вы фиксируете эти изменения и извлекаете файл снова, вы видите правильно замененное ключевое слово:

```console
$ git add date_test.txt .gitattributes
$ git commit -m "Testing date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$
```

Вы можете увидеть, насколько мощной может быть эта техника для пользовательских приложений. Вы должны быть осторожны, потому что файл `.gitattributes` фиксируется и передается вместе с проектом, но драйвер (в данном случае, `dater`) - нет, поэтому он не будет работать везде. Когда вы проектируете эти фильтры, они должны быть в состоянии изящно провалиться, и проект все еще будет работать должным образом.

### Экспорт вашего репозитория

Данные атрибутов Git также позволяют делать некоторые интересные вещи при экспорте архива вашего проекта.

#### `export-ignore`

Вы можете указать Git не экспортировать определенные файлы или каталоги при создании архива. Если есть подкаталог или файл, который вы не хотите включать в свой архивный файл, но который вы действительно хотите включить в свой проект, вы можете определить эти файлы с помощью атрибута `export-ignore`.

Например, скажем, у вас есть несколько тестовых файлов в подкаталоге `test/`, и нет смысла включать их в экспорт tarball вашего проекта. Вы можете добавить следующую строку в ваш файл атрибутов Git:

```ini
test/ export-ignore
```

Теперь, когда вы запустите `git archive` для создания архива вашего проекта, этот каталог не будет включен в архив.

#### `export-subst`

При экспорте файлов для развертывания вы можете применить форматирование `git log` и обработку раскрытия ключевых слов к отдельным частям файлов, помеченным атрибутом `export-subst`.

Например, если вы хотите включить в свой проект файл с именем `LAST_COMMIT` и автоматически вставлять в него метаданные о последнем коммите при запуске `git archive`, вы можете, например, настроить свои `.gitattributes` и `LAST_COMMIT` файлы вроде этого:

```ini
LAST_COMMIT export-subst
```

```console
$ echo 'Last commit date: $Format:%cd by %aN$' > LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'
```

Когда вы запускаете `git archive`, содержимое архивного файла будет выглядеть так:

```console
$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon
```

Замены могут включать, например, сообщение о коммите и любые `git notes`, а `git log` может выполнять простой перенос слов:

```console
$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' > LAST_COMMIT
$ git commit -am 'export-subst uses git log'\''s custom formatter

git archive uses git log'\''s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.
```

Полученный архив пригоден для развертывания, но, как и любой экспортированный архив, он не подходит для дальнейшей разработки.

### Стратегии слияния

Вы также можете использовать атрибуты Git, чтобы указать Git использовать разные стратегии слияния для конкретных файлов в вашем проекте. Одним из очень полезных вариантов является указание Git не пытаться объединять определенные файлы, когда у них возникают конфликты, а использовать вашу сторону слияния с чужими.

Это полезно, если ветка в вашем проекте разошлась или является специализированной, но вы хотите иметь возможность объединять в нее изменения и хотите игнорировать определенные файлы. Допустим, у вас есть файл настроек базы данных с именем «database.xml», который отличается в двух ветвях, и вы хотите объединить другую ветку, не перепутав файл базы данных. Вы можете настроить атрибут следующим образом:

```ini
database.xml merge=ours
```

А затем определите фиктивную "нашу" стратегию слияния с помощью:

```console
$ git config --global merge.ours.driver true
```

Если вы выполняете слияние в другой ветке, вместо конфликтов слияния с файлом `database.xml` вы видите что-то вроде этого:

```console
$ git merge topic
Auto-merging database.xml
Merge made by recursive.
```

In this case,`database.xml`stays at whatever version you originally had.


**********
[gitattributes](/tags/gitattributes.md)
[атрибуты](/tags/%D0%B0%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D1%8B.md)
